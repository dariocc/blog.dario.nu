---
title: "Building a i686 CLI application Flatpak"
date: 2021-10-17T06:00:00+02:00
draft: true
---

Undeniably, Linux package managers make installation of software piece of cake 
for users. From a developer perspective however, packaging and distribution of 
that software is not always great fun.

On one side, you have to deal with different package formats `deb`, `rpm`, ... Then there is
the fact that different distros use different naming schemas for dependencies which means that the 
`rpm` you'll create for this one distro won't work on this one other. Sometimes you even need to 
package differently for different versions of the same distro, because things such as _glibc_ 
might have changed and your application needs to be re-built linking the updated libraries.

No wonder then that many developers simply give-up and either provide distro packages for a couple
of famous distros or simply let you know that you should build from the sources. Even if Linux users
are in many cases capable of doing so we can probably agree that user experience is undoubtedly 
impoverished. 

As a developer, I want as many users to be able to benefit of my software creations and having the users 
deal of what I call _installation bureaucracy_ doesn't help me reach that goal.

Flatpak is a technology that promises to resolve this and other issues of today's distribution 
of Linux Desktop software. They tell that you'll be able to build that just one package to distribute 
to all linux distributions. A sort of *universal linux distribution package manager* for linux, but
also a sort of *common runtime* that applications can be built on. In the flatpak offer we also get
*sandboxing* and *package layering*.

They promise your distribution package will be possible to install in any Linux OS that supports 
flatpak. Notice however, the _desktop_ part: Flatpak is better suited for _desktop_ applications.

The number of Linux distros supporting Flatpaks is large enough to satisfy standard developer
distribution needs:

image::/flatpak-supported-distros.png[]

That is at least several times larger than the typical reduced set of Linux distros that 
individual developers tend to package their applications.

== The idea isn't new or unique

Flatpak isn't allow in its mission of making application distribution accessible
for developers. https://snapcraft.io[Snaps] and https://appimage.org[AppImages] are other 
contenders in the battle of multi-distro software packaging and distribution. I'd say however
that Snap and Flatpak are far more close to each other than to AppImage.

From an operations perspective, Flatpak and Snaps provide package manager, while AppImage
allows for single binary distribution. Technology wise Flatpak and Snaps are closer than
AppImage and see the later as a _different beast_ and I'd be more interested in it if I intend
to distribute the binaries from my own site rather than through a centralized repository.

I personally enjoy a lot _software repositories_ vs the traditional scattered download approach
seen in other  OS. The idea has been proven to be successful not only in desktop but in
mobile environments.

As a free software Linux user, I would definitely prefer Flatpak. Snap is IMO too tight to 
Canonical, specially when it comes to application distribution, which happens through
their centralized _Snap Store_ repository and which __is not open source__. The store API
is though public and it is technically possible for someone to come with an alternative
solution, but that's not the same that just being able to run your store backend with your
defined collection of software. Snaps do not have the notion of multiple _repositories_ as
traditional package managers do. Flatpak does. Snap developers argue, not without reason, that
having multiple repositories is harmful from the perspective of consuming software.

I'd say that from privative software perspective I've seen far more success of
Snaps than I see from Flatpak. It is far more likely to find officially packaged
software such as Spotify, VsCode, etc. in the snap store than in Flathub. People still package
those software and will make it available to the masses, but arguably that is far from ideal
since I always prefer to get software from the creators.

Companies support to Snap doesn't necessarily come from the fact that the technology is superior
to Flatpak. There might simply be a better marketing or relationship work from Canonical to partner
with these big actors.

But from a truly free (as in freedom) software perspective, I cannot but favor Flatpak over
Snap. I won't be hosting my own repositories, but I'm calm with the idea knowing that someone else
is able to and that the risk of vendor-locking is reduced.

In any case, this post wasn't intended to be a comparison between the different software distribution
packages alternatives but rather show an applied example of how I built a Flatpak to resolve a
32bits application software distribution issue.

## Building a 32bits CLI Application with Flatpak

We are gonna Flatpak for a C application which
is slightly more complicated than the _Hello Flatpak!_ example of the official Flatpak
guide. 

We are gonna be packaging https://www.bennugd.org:[BennuGD], a multi-platform video-game
programming language. The reasons why I chose this project are irrelevant what matters is
that this software has a set 

1. It needs to be built against 32bits libraries.
2. It depends on old libraries such as SDL Lib 1.2 which are not part of the common runtime
   that flatpak applications normally build against.
3. It's a CLI application. Most Flatpaks are GUI applications and some would argue that those
   are the real _desktop_ applications. For me desktop goes further than that, since I use a lot
   of CLI daily and the different is more against _server_ applications.
4. It has always suffered from not being easily distributable in Linux, resulting in that
   most of the times you had to build it yourself.

### The plan

1. Know how to get the sources.
2. Know how to build the sources. In particular, learn about necessary dependencies.
3. If necessary, create a patch for the sources.
4. Create a Flatpak manifest to build the 32bits app.

### Know how to get the sources


## Some Takeaways

After this experience of building Flatpak, here there are some likes and dislikes.

Liked:

* It works: build once and deploy everywhere.
* Everything within it is open source.
* Documentation is relatively good.
* Centralized app https://flathub.org[repository], so one still has the benefit of _package managers_.
* You can host your own repositories (good for organizations).
* Good, informative, package manager CLI.
* Developers can push updates to applications and users can fetch them immediately.

Disliked:

* Documentation is good, but not always comprehensive. Some advances use cases aren't
  documented and it takes a lot of try-and-error to understand how things work.
* _Future-proof builds_ is true in theory, but in practice developers are expected 
  to keep updating their packages, otherwise they risk not fixing security issues.
  Newer runtimes mean also having to target newer versions of glibc, which may require
  developers to modify their applications.
* Building for 32bit architecture requires far more work than building a 64bits one.
* Composability of manifest needs more work.
* Primarily conceived for _desktop applications_. Possible to use for console applications.

There are other _disadvantages_ such as the additional disk size required. With the
price of hard and sdd disks constantly dropping this is however not a disadvantage to me.

I wish there was some sort of built-in monetization mechanisms for supporting open
source projects. I think the linux community would benefit of developers being
actually paid, even if it is in som sort of _donation_ model.

////

* [ ] Speak about the _hidden folder_ and how to _run into the flatpak_.

////

